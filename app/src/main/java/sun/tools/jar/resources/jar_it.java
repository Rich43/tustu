package sun.tools.jar.resources;

import java.util.ListResourceBundle;

/* loaded from: rt.jar:sun/tools/jar/resources/jar_it.class */
public final class jar_it extends ListResourceBundle {
    /* JADX WARN: Type inference failed for: r0v1, types: [java.lang.Object[], java.lang.Object[][]] */
    @Override // java.util.ListResourceBundle
    protected final Object[][] getContents() {
        return new Object[]{new Object[]{"error.bad.cflag", "Per il flag 'c' è necessario specificare file manifest o di input."}, new Object[]{"error.bad.eflag", "Il flag 'e' e il manifest con l'attributo 'Main-Class' non possono essere specificati\ninsieme."}, new Object[]{"error.bad.option", "È necessario specificare una delle opzioni -{ctxu}."}, new Object[]{"error.bad.uflag", "Per il flag 'u' è necessario specificare il flag 'e' oppure file manifest o di input."}, new Object[]{"error.cant.open", "impossibile aprire: {0} "}, new Object[]{"error.create.dir", "{0} : impossibile creare la directory"}, new Object[]{"error.create.tempfile", "Impossibile creare il file temporaneo."}, new Object[]{"error.illegal.option", "Opzione non valida: {0}"}, new Object[]{"error.incorrect.length", "lunghezza non valida durante l''elaborazione: {0}"}, new Object[]{"error.nosuch.fileordir", "{0} : file o directory inesistente"}, new Object[]{"error.write.file", "Errore durante la scrittura del file jar esistente"}, new Object[]{"out.added.manifest", "aggiunto manifest"}, new Object[]{"out.adding", "aggiunta in corso di: {0}"}, new Object[]{"out.create", "     creato: {0}"}, new Object[]{"out.deflated", "(compresso {0}%)"}, new Object[]{"out.extracted", "estratto: {0}"}, new Object[]{"out.ignore.entry", "la voce {0} sarà ignorata"}, new Object[]{"out.inflated", " decompresso: {0}"}, new Object[]{"out.size", "(in = {0}) (out = {1})"}, new Object[]{"out.stored", "(memorizzato 0%)"}, new Object[]{"out.update.manifest", "aggiornato manifest"}, new Object[]{"usage", "Uso: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...\nOpzioni:\n    -c  crea un nuovo archivio\n    -t  visualizza l'indice dell'archivio\n    -x  estrae i file con nome (o tutti i file) dall'archivio\n    -u  aggiorna l'archivio esistente\n    -v  genera output commentato dall'output standard\n    -f  specifica il nome file dell'archivio\n    -m  include informazioni manifest dal file manifest specificato\n    -n  esegue normalizzazione Pack200 dopo la creazione di un nuovo archivio\n    -e  specifica il punto di ingresso per l'applicazione stand-alone \n        inclusa nel file jar eseguibile\n    -0  solo memorizzazione; senza compressione ZIP\n    -P  conserva i componenti iniziali '/' (percorso assoluto) e \\\"..\\\" (directory padre) dai nomi file\n    -M  consente di non creare un file manifest per le voci\n    -i  genera informazioni sull'indice per i file jar specificati\n    -C  imposta la directory specificata e include il file seguente\nSe un file è una directory, verrà elaborato in modo ricorsivo.\nIl nome del file manifest, del file di archivio e del punto di ingresso devono\nessere specificati nello stesso ordine dei flag 'm', 'f' ed 'e'.\n\nEsempio 1: archiviazione di due file di classe in un archivio con il nome classes.jar: \n       jar cvf classes.jar Foo.class Bar.class \nEsempio 2: utilizzo del file manifest esistente 'mymanifest' e archiviazione di tutti i\n           file della directory foo/ in 'classes.jar': \n       jar cvfm classes.jar mymanifest -C foo/ .\n"}};
    }
}
