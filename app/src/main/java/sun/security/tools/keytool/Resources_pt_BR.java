package sun.security.tools.keytool;

import java.util.ListResourceBundle;
import org.icepdf.core.util.PdfOps;

/* loaded from: rt.jar:sun/security/tools/keytool/Resources_pt_BR.class */
public class Resources_pt_BR extends ListResourceBundle {
    private static final Object[][] contents = {new Object[]{"NEWLINE", "\n"}, new Object[]{"STAR", "*******************************************"}, new Object[]{"STARNN", "*******************************************\n\n"}, new Object[]{".OPTION.", " [OPTION]..."}, new Object[]{"Options.", "Opções:"}, new Object[]{"Use.keytool.help.for.all.available.commands", "Use \"keytool -help\" para todos os comandos disponíveis"}, new Object[]{"Key.and.Certificate.Management.Tool", "Ferramenta de Gerenciamento de Chave e Certificado"}, new Object[]{"Commands.", "Comandos:"}, new Object[]{"Use.keytool.command.name.help.for.usage.of.command.name", "Use \"keytool -command_name -help\" para uso de command_name"}, new Object[]{"Generates.a.certificate.request", "Gera uma solicitação de certificado"}, new Object[]{"Changes.an.entry.s.alias", "Altera um alias de entrada"}, new Object[]{"Deletes.an.entry", "Exclui uma entrada"}, new Object[]{"Exports.certificate", "Exporta o certificado"}, new Object[]{"Generates.a.key.pair", "Gera um par de chaves"}, new Object[]{"Generates.a.secret.key", "Gera uma chave secreta"}, new Object[]{"Generates.certificate.from.a.certificate.request", "Gera um certificado de uma solicitação de certificado"}, new Object[]{"Generates.CRL", "Gera CRL"}, new Object[]{"Generated.keyAlgName.secret.key", "Chave secreta {0} gerada"}, new Object[]{"Generated.keysize.bit.keyAlgName.secret.key", "Chave secreta {1} de {0} bits gerada"}, new Object[]{"Imports.entries.from.a.JDK.1.1.x.style.identity.database", "Importa entradas de um banco de dados de identidade JDK 1.1.x-style"}, new Object[]{"Imports.a.certificate.or.a.certificate.chain", "Importa um certificado ou uma cadeia de certificados"}, new Object[]{"Imports.a.password", "Importa uma senha"}, new Object[]{"Imports.one.or.all.entries.from.another.keystore", "Importa uma ou todas as entradas de outra área de armazenamento de chaves"}, new Object[]{"Clones.a.key.entry", "Clona uma entrada de chave"}, new Object[]{"Changes.the.key.password.of.an.entry", "Altera a senha da chave de uma entrada"}, new Object[]{"Lists.entries.in.a.keystore", "Lista entradas em uma área de armazenamento de chaves"}, new Object[]{"Prints.the.content.of.a.certificate", "Imprime o conteúdo de um certificado"}, new Object[]{"Prints.the.content.of.a.certificate.request", "Imprime o conteúdo de uma solicitação de certificado"}, new Object[]{"Prints.the.content.of.a.CRL.file", "Imprime o conteúdo de um arquivo CRL"}, new Object[]{"Generates.a.self.signed.certificate", "Gera um certificado autoassinado"}, new Object[]{"Changes.the.store.password.of.a.keystore", "Altera a senha de armazenamento de uma área de armazenamento de chaves"}, new Object[]{"alias.name.of.the.entry.to.process", "nome do alias da entrada a ser processada"}, new Object[]{"destination.alias", "alias de destino"}, new Object[]{"destination.key.password", "senha da chave de destino"}, new Object[]{"destination.keystore.name", "nome da área de armazenamento de chaves de destino"}, new Object[]{"destination.keystore.password.protected", "senha protegida da área de armazenamento de chaves de destino"}, new Object[]{"destination.keystore.provider.name", "nome do fornecedor da área de armazenamento de chaves de destino"}, new Object[]{"destination.keystore.password", "senha da área de armazenamento de chaves de destino"}, new Object[]{"destination.keystore.type", "tipo de área de armazenamento de chaves de destino"}, new Object[]{"distinguished.name", "nome distinto"}, new Object[]{"X.509.extension", "extensão X.509"}, new Object[]{"output.file.name", "nome do arquivo de saída"}, new Object[]{"input.file.name", "nome do arquivo de entrada"}, new Object[]{"key.algorithm.name", "nome do algoritmo da chave"}, new Object[]{"key.password", "senha da chave"}, new Object[]{"key.bit.size", "tamanho do bit da chave"}, new Object[]{"keystore.name", "nome da área de armazenamento de chaves"}, new Object[]{"new.password", "nova senha"}, new Object[]{"do.not.prompt", "não perguntar"}, new Object[]{"password.through.protected.mechanism", "senha por meio de mecanismo protegido"}, new Object[]{"provider.argument", "argumento do fornecedor"}, new Object[]{"provider.class.name", "nome da classe do fornecedor"}, new Object[]{"provider.name", "nome do fornecedor"}, new Object[]{"provider.classpath", "classpath do fornecedor"}, new Object[]{"output.in.RFC.style", "saída no estilo RFC"}, new Object[]{"signature.algorithm.name", "nome do algoritmo de assinatura"}, new Object[]{"source.alias", "alias de origem"}, new Object[]{"source.key.password", "senha da chave de origem"}, new Object[]{"source.keystore.name", "nome da área de armazenamento de chaves de origem"}, new Object[]{"source.keystore.password.protected", "senha protegida da área de armazenamento de chaves de origem"}, new Object[]{"source.keystore.provider.name", "nome do fornecedor da área de armazenamento de chaves de origem"}, new Object[]{"source.keystore.password", "senha da área de armazenamento de chaves de origem"}, new Object[]{"source.keystore.type", "tipo de área de armazenamento de chaves de origem"}, new Object[]{"SSL.server.host.and.port", "porta e host do servidor SSL"}, new Object[]{"signed.jar.file", "arquivo jar assinado"}, new Object[]{"certificate.validity.start.date.time", "data/hora inicial de validade do certificado"}, new Object[]{"keystore.password", "senha da área de armazenamento de chaves"}, new Object[]{"keystore.type", "tipo de área de armazenamento de chaves"}, new Object[]{"trust.certificates.from.cacerts", "certificados confiáveis do cacerts"}, new Object[]{"verbose.output", "saída detalhada"}, new Object[]{"validity.number.of.days", "número de dias da validade"}, new Object[]{"Serial.ID.of.cert.to.revoke", "ID de série do certificado a ser revogado"}, new Object[]{"keytool.error.", "erro de keytool: "}, new Object[]{"Illegal.option.", "Opção inválida:  "}, new Object[]{"Illegal.value.", "Valor inválido: "}, new Object[]{"Unknown.password.type.", "Tipo de senha desconhecido: "}, new Object[]{"Cannot.find.environment.variable.", "Não é possível localizar a variável do ambiente: "}, new Object[]{"Cannot.find.file.", "Não é possível localizar o arquivo: "}, new Object[]{"Command.option.flag.needs.an.argument.", "A opção de comando {0} precisa de um argumento."}, new Object[]{"Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.", "Advertência: Senhas de chave e de armazenamento diferentes não suportadas para KeyStores PKCS12. Ignorando valor {0} especificado pelo usuário."}, new Object[]{".keystore.must.be.NONE.if.storetype.is.{0}", "-keystore deve ser NONE se -storetype for {0}"}, new Object[]{"Too.many.retries.program.terminated", "Excesso de tentativas de repetição; programa finalizado"}, new Object[]{".storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}", "comandos -storepasswd e -keypasswd não suportados se -storetype for {0}"}, new Object[]{".keypasswd.commands.not.supported.if.storetype.is.PKCS12", "comandos -keypasswd não suportados se -storetype for PKCS12"}, new Object[]{".keypass.and.new.can.not.be.specified.if.storetype.is.{0}", "-keypass e -new não podem ser especificados se -storetype for {0}"}, new Object[]{"if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified", "se -protected for especificado, então -storepass, -keypass e -new não deverão ser especificados"}, new Object[]{"if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified", "se -srcprotected for especificado, então -srcstorepass e -srckeypass não deverão ser especificados"}, new Object[]{"if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified", "se a área de armazenamento de chaves não estiver protegida por senha, então -storepass, -keypass e -new não deverão ser especificados"}, new Object[]{"if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified", "se a área de armazenamento de chaves de origem não estiver protegida por senha, então -srcstorepass e -srckeypass não deverão ser especificados"}, new Object[]{"Illegal.startdate.value", "valor da data inicial inválido"}, new Object[]{"Validity.must.be.greater.than.zero", "A validade deve ser maior do que zero"}, new Object[]{"provName.not.a.provider", "{0} não é um fornecedor"}, new Object[]{"Usage.error.no.command.provided", "Erro de uso: nenhum comando fornecido"}, new Object[]{"Source.keystore.file.exists.but.is.empty.", "O arquivo da área de armazenamento de chaves de origem existe, mas está vazio: "}, new Object[]{"Please.specify.srckeystore", "Especifique -srckeystore"}, new Object[]{"Must.not.specify.both.v.and.rfc.with.list.command", "Não devem ser especificados -v e -rfc com o comando 'list'"}, new Object[]{"Key.password.must.be.at.least.6.characters", "A senha da chave deve ter, no mínimo, 6 caracteres"}, new Object[]{"New.password.must.be.at.least.6.characters", "A nova senha deve ter, no mínimo, 6 caracteres"}, new Object[]{"Keystore.file.exists.but.is.empty.", "O arquivo da área de armazenamento de chaves existe, mas está vazio: "}, new Object[]{"Keystore.file.does.not.exist.", "O arquivo da área de armazenamento de chaves não existe. "}, new Object[]{"Must.specify.destination.alias", "Deve ser especificado um alias de destino"}, new Object[]{"Must.specify.alias", "Deve ser especificado um alias"}, new Object[]{"Keystore.password.must.be.at.least.6.characters", "A senha da área de armazenamento de chaves deve ter, no mínimo, 6 caracteres"}, new Object[]{"Enter.the.password.to.be.stored.", "Digite a senha a ser armazenada:  "}, new Object[]{"Enter.keystore.password.", "Informe a senha da área de armazenamento de chaves:  "}, new Object[]{"Enter.source.keystore.password.", "Informe a senha da área de armazenamento de chaves de origem:  "}, new Object[]{"Enter.destination.keystore.password.", "Informe a senha da área de armazenamento de chaves de destino:  "}, new Object[]{"Keystore.password.is.too.short.must.be.at.least.6.characters", "A senha da área de armazenamento de chaves é muito curta - ela deve ter, no mínimo, 6 caracteres"}, new Object[]{"Unknown.Entry.Type", "Tipo de Entrada Desconhecido"}, new Object[]{"Too.many.failures.Alias.not.changed", "Excesso de falhas. Alias não alterado"}, new Object[]{"Entry.for.alias.alias.successfully.imported.", "Entrada do alias {0} importada com êxito."}, new Object[]{"Entry.for.alias.alias.not.imported.", "Entrada do alias {0} não importada."}, new Object[]{"Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.", "Problema ao importar a entrada do alias {0}: {1}.\nEntrada do alias {0} não importada."}, new Object[]{"Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled", "Comando de importação concluído:  {0} entradas importadas com êxito, {1} entradas falharam ou foram canceladas"}, new Object[]{"Warning.Overwriting.existing.alias.alias.in.destination.keystore", "Advertência: Substituição do alias {0} existente na área de armazenamento de chaves de destino"}, new Object[]{"Existing.entry.alias.alias.exists.overwrite.no.", "Entrada já existente no alias {0}, substituir? [não]:  "}, new Object[]{"Too.many.failures.try.later", "Excesso de falhas - tente mais tarde"}, new Object[]{"Certification.request.stored.in.file.filename.", "Solicitação de certificado armazenada no arquivo <{0}>"}, new Object[]{"Submit.this.to.your.CA", "Submeter à CA"}, new Object[]{"if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified", "se o alias não estiver especificado, destalias e srckeypass não deverão ser especificados"}, new Object[]{"The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.", "O armazenamento de chaves pkcs12 de destino tem storepass e keypass diferentes. Tente novamente especificando -destkeypass."}, new Object[]{"Certificate.stored.in.file.filename.", "Certificado armazenado no arquivo <{0}>"}, new Object[]{"Certificate.reply.was.installed.in.keystore", "A resposta do certificado foi instalada na área de armazenamento de chaves"}, new Object[]{"Certificate.reply.was.not.installed.in.keystore", "A resposta do certificado não foi instalada na área de armazenamento de chaves"}, new Object[]{"Certificate.was.added.to.keystore", "O certificado foi adicionado à área de armazenamento de chaves"}, new Object[]{"Certificate.was.not.added.to.keystore", "O certificado não foi adicionado à área de armazenamento de chaves"}, new Object[]{".Storing.ksfname.", "[Armazenando {0}]"}, new Object[]{"alias.has.no.public.key.certificate.", "{0} não tem chave pública (certificado)"}, new Object[]{"Cannot.derive.signature.algorithm", "Não é possível obter um algoritmo de assinatura"}, new Object[]{"Alias.alias.does.not.exist", "O alias <{0}> não existe"}, new Object[]{"Alias.alias.has.no.certificate", "O alias <{0}> não tem certificado"}, new Object[]{"Key.pair.not.generated.alias.alias.already.exists", "Par de chaves não gerado; o alias <{0}> já existe"}, new Object[]{"Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for", "Gerando o par de chaves {1} de {0} bit e o certificado autoassinado ({2}) com uma validade de {3} dias\n\tpara: {4}"}, new Object[]{"Enter.key.password.for.alias.", "Informar a senha da chave de <{0}>"}, new Object[]{".RETURN.if.same.as.keystore.password.", "\t(RETURN se for igual à senha da área do armazenamento de chaves):  "}, new Object[]{"Key.password.is.too.short.must.be.at.least.6.characters", "A senha da chave é muito curta - deve ter, no mínimo, 6 caracteres"}, new Object[]{"Too.many.failures.key.not.added.to.keystore", "Excesso de falhas - chave não adicionada a área de armazenamento de chaves"}, new Object[]{"Destination.alias.dest.already.exists", "O alias de destino <{0}> já existe"}, new Object[]{"Password.is.too.short.must.be.at.least.6.characters", "A senha é muito curta - deve ter, no mínimo, 6 caracteres"}, new Object[]{"Too.many.failures.Key.entry.not.cloned", "Excesso de falhas. Entrada da chave não clonada"}, new Object[]{"key.password.for.alias.", "senha da chave de <{0}>"}, new Object[]{"Keystore.entry.for.id.getName.already.exists", "A entrada da área do armazenamento de chaves de <{0}> já existe"}, new Object[]{"Creating.keystore.entry.for.id.getName.", "Criando entrada da área do armazenamento de chaves para <{0}> ..."}, new Object[]{"No.entries.from.identity.database.added", "Nenhuma entrada adicionada do banco de dados de identidades"}, new Object[]{"Alias.name.alias", "Nome do alias: {0}"}, new Object[]{"Creation.date.keyStore.getCreationDate.alias.", "Data de criação: {0,date}"}, new Object[]{"alias.keyStore.getCreationDate.alias.", "{0}, {1,date}, "}, new Object[]{"alias.", "{0}, "}, new Object[]{"Entry.type.type.", "Tipo de entrada: {0}"}, new Object[]{"Certificate.chain.length.", "Comprimento da cadeia de certificados: "}, new Object[]{"Certificate.i.1.", "Certificado[{0,number,integer}]:"}, new Object[]{"Certificate.fingerprint.SHA1.", "Fingerprint (SHA1) do certificado: "}, new Object[]{"Keystore.type.", "Tipo de área de armazenamento de chaves: "}, new Object[]{"Keystore.provider.", "Fornecedor da área de armazenamento de chaves: "}, new Object[]{"Your.keystore.contains.keyStore.size.entry", "Sua área de armazenamento de chaves contém {0,number,integer} entrada"}, new Object[]{"Your.keystore.contains.keyStore.size.entries", "Sua área de armazenamento de chaves contém {0,number,integer} entradas"}, new Object[]{"Failed.to.parse.input", "Falha durante o parsing da entrada"}, new Object[]{"Empty.input", "Entrada vazia"}, new Object[]{"Not.X.509.certificate", "Não é um certificado X.509"}, new Object[]{"alias.has.no.public.key", "{0} não tem chave pública"}, new Object[]{"alias.has.no.X.509.certificate", "{0} não tem certificado X.509"}, new Object[]{"New.certificate.self.signed.", "Novo certificado (autoassinado):"}, new Object[]{"Reply.has.no.certificates", "A resposta não tem certificado"}, new Object[]{"Certificate.not.imported.alias.alias.already.exists", "Certificado não importado, o alias <{0}> já existe"}, new Object[]{"Input.not.an.X.509.certificate", "A entrada não é um certificado X.509"}, new Object[]{"Certificate.already.exists.in.keystore.under.alias.trustalias.", "O certificado já existe no armazenamento de chaves no alias <{0}>"}, new Object[]{"Do.you.still.want.to.add.it.no.", "Ainda deseja adicioná-lo? [não]:  "}, new Object[]{"Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.", "O certificado já existe na área de armazenamento de chaves da CA em todo o sistema no alias <{0}>"}, new Object[]{"Do.you.still.want.to.add.it.to.your.own.keystore.no.", "Ainda deseja adicioná-lo à sua área de armazenamento de chaves? [não]:  "}, new Object[]{"Trust.this.certificate.no.", "Confiar neste certificado? [não]:  "}, new Object[]{"YES", "SIM"}, new Object[]{"New.prompt.", "Nova {0}: "}, new Object[]{"Passwords.must.differ", "As senhas devem ser diferentes"}, new Object[]{"Re.enter.new.prompt.", "Informe novamente a nova {0}: "}, new Object[]{"Re.enter.password.", "Redigite a senha: "}, new Object[]{"Re.enter.new.password.", "Informe novamente a nova senha: "}, new Object[]{"They.don.t.match.Try.again", "Elas não correspondem. Tente novamente"}, new Object[]{"Enter.prompt.alias.name.", "Informe o nome do alias {0}:  "}, new Object[]{"Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.", "Informe o novo nome do alias\t(RETURN para cancelar a importação desta entrada):  "}, new Object[]{"Enter.alias.name.", "Informe o nome do alias:  "}, new Object[]{".RETURN.if.same.as.for.otherAlias.", "\t(RETURN se for igual ao de <{0}>)"}, new Object[]{"What.is.your.first.and.last.name.", "Qual é o seu nome e o seu sobrenome?"}, new Object[]{"What.is.the.name.of.your.organizational.unit.", "Qual é o nome da sua unidade organizacional?"}, new Object[]{"What.is.the.name.of.your.organization.", "Qual é o nome da sua empresa?"}, new Object[]{"What.is.the.name.of.your.City.or.Locality.", "Qual é o nome da sua Cidade ou Localidade?"}, new Object[]{"What.is.the.name.of.your.State.or.Province.", "Qual é o nome do seu Estado ou Município?"}, new Object[]{"What.is.the.two.letter.country.code.for.this.unit.", "Quais são as duas letras do código do país desta unidade?"}, new Object[]{"Is.name.correct.", "{0} Está correto?"}, new Object[]{"no", "não"}, new Object[]{"yes", "sim"}, new Object[]{PdfOps.y_TOKEN, PdfOps.s_TOKEN}, new Object[]{".defaultValue.", "  [{0}]:  "}, new Object[]{"Alias.alias.has.no.key", "O alias <{0}> não tem chave"}, new Object[]{"Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key", "O alias <{0}> faz referência a um tipo de entrada que não é uma entrada de chave privada. O comando -keyclone oferece suporte somente à clonagem de entradas de chave privada"}, new Object[]{".WARNING.WARNING.WARNING.", "*****************  WARNING WARNING WARNING  *****************"}, new Object[]{"Signer.d.", "Signatário #%d:"}, new Object[]{"Timestamp.", "Timestamp:"}, new Object[]{"Signature.", "Assinatura:"}, new Object[]{"CRLs.", "CRLs:"}, new Object[]{"Certificate.owner.", "Proprietário do certificado: "}, new Object[]{"Not.a.signed.jar.file", "Não é um arquivo jar assinado"}, new Object[]{"No.certificate.from.the.SSL.server", "Não é um certificado do servidor SSL"}, new Object[]{".The.integrity.of.the.information.stored.in.your.keystore.", "* A integridade das informações armazenadas na sua área de armazenamento de chaves  *\n* NÃO foi verificada!  Para que seja possível verificar sua integridade, *\n* você deve fornecer a senha da área de armazenamento de chaves.                  *"}, new Object[]{".The.integrity.of.the.information.stored.in.the.srckeystore.", "* A integridade das informações armazenadas no srckeystore  *\n* NÃO foi verificada!  Para que seja possível verificar sua integridade, *\n* você deve fornecer a senha do srckeystore.                  *"}, new Object[]{"Certificate.reply.does.not.contain.public.key.for.alias.", "A resposta do certificado não contém a chave pública de <{0}>"}, new Object[]{"Incomplete.certificate.chain.in.reply", "Cadeia de certificados incompleta na resposta"}, new Object[]{"Certificate.chain.in.reply.does.not.verify.", "A cadeia de certificados da resposta não verifica: "}, new Object[]{"Top.level.certificate.in.reply.", "Certificado de nível superior na resposta:\n"}, new Object[]{".is.not.trusted.", "... não é confiável. "}, new Object[]{"Install.reply.anyway.no.", "Instalar resposta assim mesmo? [não]:  "}, new Object[]{"NO", "NÃO"}, new Object[]{"Public.keys.in.reply.and.keystore.don.t.match", "As chaves públicas da resposta e da área de armazenamento de chaves não correspondem"}, new Object[]{"Certificate.reply.and.certificate.in.keystore.are.identical", "O certificado da resposta e o certificado da área de armazenamento de chaves são idênticos"}, new Object[]{"Failed.to.establish.chain.from.reply", "Falha ao estabelecer a cadeia a partir da resposta"}, new Object[]{PdfOps.n_TOKEN, PdfOps.n_TOKEN}, new Object[]{"Wrong.answer.try.again", "Resposta errada; tente novamente"}, new Object[]{"Secret.key.not.generated.alias.alias.already.exists", "Chave secreta não gerada; o alias <{0}> já existe"}, new Object[]{"Please.provide.keysize.for.secret.key.generation", "Forneça o -keysize para a geração da chave secreta"}, new Object[]{"warning.not.verified.make.sure.keystore.is.correct", "ADVERTÊNCIA: não verificado. Certifique-se que -keystore esteja correto."}, new Object[]{"Extensions.", "Extensões: "}, new Object[]{".Empty.value.", "(Valor vazio)"}, new Object[]{"Extension.Request.", "Solicitação de Extensão:"}, new Object[]{"Unknown.keyUsage.type.", "Tipo de keyUsage desconhecido: "}, new Object[]{"Unknown.extendedkeyUsage.type.", "Tipo de extendedkeyUsage desconhecido: "}, new Object[]{"Unknown.AccessDescription.type.", "Tipo de AccessDescription desconhecido: "}, new Object[]{"Unrecognized.GeneralName.type.", "Tipo de GeneralName não reconhecido: "}, new Object[]{"This.extension.cannot.be.marked.as.critical.", "Esta extensão não pode ser marcada como crítica. "}, new Object[]{"Odd.number.of.hex.digits.found.", "Encontrado número ímpar de seis dígitos: "}, new Object[]{"Unknown.extension.type.", "Tipo de extensão desconhecido: "}, new Object[]{"command.{0}.is.ambiguous.", "o comando {0} é ambíguo:"}, new Object[]{"the.certificate.request", "A solicitação do certificado"}, new Object[]{"the.issuer", "O emissor"}, new Object[]{"the.generated.certificate", "O certificado gerado"}, new Object[]{"the.generated.crl", "A CRL gerada"}, new Object[]{"the.generated.certificate.request", "A solicitação do certificado gerada"}, new Object[]{"the.certificate", "O certificado"}, new Object[]{"the.crl", "A CRL"}, new Object[]{"the.tsa.certificate", "O certificado TSA"}, new Object[]{"the.input", "A entrada"}, new Object[]{"reply", "Resposta"}, new Object[]{"one.in.many", "%1$s #%2$d de %3$d"}, new Object[]{"alias.in.cacerts", "Emissor <%s> no cacerts"}, new Object[]{"alias.in.keystore", "Emissor <%s>"}, new Object[]{"with.weak", "%s (fraca)"}, new Object[]{"key.bit", "Chave %2$s de %1$d bits"}, new Object[]{"key.bit.weak", "Chave %2$s de %1$d bits (fraca)"}, new Object[]{".PATTERN.printX509Cert.with.weak", "Proprietário: {0}\nEmissor: {1}\nNúmero de série: {2}\nVálido de {3} até {4}\nFingerprints do certificado:\n\t MD5:  {5}\n\t SHA1: {6}\n\t SHA256: {7}\nNome do algoritmo de assinatura: {8}\nAlgoritmo de Chave Pública do Assunto: {9}\nVersão: {10}"}, new Object[]{"PKCS.10.with.weak", "Solicitação do Certificado PKCS #10 (Versão 1.0)\nAssunto: %1$s\nFormato: %2$s\nChave Pública: %3$s\nAlgoritmo de assinatura: %4$s\n"}, new Object[]{"verified.by.s.in.s.weak", "Verificado por %1$s em %2$s com um %3$s"}, new Object[]{"whose.sigalg.risk", "%1$s usa o algoritmo de assinatura %2$s que é considerado um risco à segurança."}, new Object[]{"whose.key.risk", "%1$s usa um %2$s que é considerado um risco à segurança."}, new Object[]{"jks.storetype.warning", "O armazenamento de chaves %1$s usa um formato proprietário. É recomendada a migração para PKCS12, que é um formato de padrão industrial que usa \"keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\"."}, new Object[]{"migrate.keystore.warning", "\"%1$s\" foi migrado para %4$s. O backup do armazenamento de chaves %2$s é feito como \"%3$s\"."}, new Object[]{"backup.keystore.warning", "O backup do armazenamento de chaves original \"%1$s\" é feito como \"%3$s\"..."}, new Object[]{"importing.keystore.status", "Importando armazenamento de chaves %1$s to %2$s..."}};

    @Override // java.util.ListResourceBundle
    public Object[][] getContents() {
        return contents;
    }
}
