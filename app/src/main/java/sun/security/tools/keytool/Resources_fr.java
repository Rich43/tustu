package sun.security.tools.keytool;

import java.util.ListResourceBundle;
import org.icepdf.core.util.PdfOps;

/* loaded from: rt.jar:sun/security/tools/keytool/Resources_fr.class */
public class Resources_fr extends ListResourceBundle {
    private static final Object[][] contents = {new Object[]{"NEWLINE", "\n"}, new Object[]{"STAR", "*******************************************"}, new Object[]{"STARNN", "*******************************************\n\n"}, new Object[]{".OPTION.", " [OPTION]..."}, new Object[]{"Options.", "Options :"}, new Object[]{"Use.keytool.help.for.all.available.commands", "Utiliser \"keytool -help\" pour toutes les commandes disponibles"}, new Object[]{"Key.and.Certificate.Management.Tool", "Outil de gestion de certificats et de clés"}, new Object[]{"Commands.", "Commandes :"}, new Object[]{"Use.keytool.command.name.help.for.usage.of.command.name", "Utiliser \"keytool -command_name -help\" pour la syntaxe de command_name"}, new Object[]{"Generates.a.certificate.request", "Génère une demande de certificat"}, new Object[]{"Changes.an.entry.s.alias", "Modifie l'alias d'une entrée"}, new Object[]{"Deletes.an.entry", "Supprime une entrée"}, new Object[]{"Exports.certificate", "Exporte le certificat"}, new Object[]{"Generates.a.key.pair", "Génère une paire de clés"}, new Object[]{"Generates.a.secret.key", "Génère une clé secrète"}, new Object[]{"Generates.certificate.from.a.certificate.request", "Génère le certificat à partir d'une demande de certificat"}, new Object[]{"Generates.CRL", "Génère la liste des certificats révoqués (CRL)"}, new Object[]{"Generated.keyAlgName.secret.key", "Clé secrète {0} générée"}, new Object[]{"Generated.keysize.bit.keyAlgName.secret.key", "Clé secrète {0} bits {1} générée"}, new Object[]{"Imports.entries.from.a.JDK.1.1.x.style.identity.database", "Importe les entrées à partir d'une base de données d'identités de type JDK 1.1.x"}, new Object[]{"Imports.a.certificate.or.a.certificate.chain", "Importe un certificat ou une chaîne de certificat"}, new Object[]{"Imports.a.password", "Importe un mot de passe"}, new Object[]{"Imports.one.or.all.entries.from.another.keystore", "Importe une entrée ou la totalité des entrées depuis un autre fichier de clés"}, new Object[]{"Clones.a.key.entry", "Clone une entrée de clé"}, new Object[]{"Changes.the.key.password.of.an.entry", "Modifie le mot de passe de clé d'une entrée"}, new Object[]{"Lists.entries.in.a.keystore", "Répertorie les entrées d'un fichier de clés"}, new Object[]{"Prints.the.content.of.a.certificate", "Imprime le contenu d'un certificat"}, new Object[]{"Prints.the.content.of.a.certificate.request", "Imprime le contenu d'une demande de certificat"}, new Object[]{"Prints.the.content.of.a.CRL.file", "Imprime le contenu d'un fichier de liste des certificats révoqués (CRL)"}, new Object[]{"Generates.a.self.signed.certificate", "Génère un certificat auto-signé"}, new Object[]{"Changes.the.store.password.of.a.keystore", "Modifie le mot de passe de banque d'un fichier de clés"}, new Object[]{"alias.name.of.the.entry.to.process", "nom d'alias de l'entrée à traiter"}, new Object[]{"destination.alias", "alias de destination"}, new Object[]{"destination.key.password", "mot de passe de la clé de destination"}, new Object[]{"destination.keystore.name", "nom du fichier de clés de destination"}, new Object[]{"destination.keystore.password.protected", "mot de passe du fichier de clés de destination protégé"}, new Object[]{"destination.keystore.provider.name", "nom du fournisseur du fichier de clés de destination"}, new Object[]{"destination.keystore.password", "mot de passe du fichier de clés de destination"}, new Object[]{"destination.keystore.type", "type du fichier de clés de destination"}, new Object[]{"distinguished.name", "nom distinctif"}, new Object[]{"X.509.extension", "extension X.509"}, new Object[]{"output.file.name", "nom du fichier de sortie"}, new Object[]{"input.file.name", "nom du fichier d'entrée"}, new Object[]{"key.algorithm.name", "nom de l'algorithme de clé"}, new Object[]{"key.password", "mot de passe de la clé"}, new Object[]{"key.bit.size", "taille en bits de la clé"}, new Object[]{"keystore.name", "nom du fichier de clés"}, new Object[]{"new.password", "nouveau mot de passe"}, new Object[]{"do.not.prompt", "ne pas inviter"}, new Object[]{"password.through.protected.mechanism", "mot de passe via mécanisme protégé"}, new Object[]{"provider.argument", "argument du fournisseur"}, new Object[]{"provider.class.name", "nom de la classe de fournisseur"}, new Object[]{"provider.name", "nom du fournisseur"}, new Object[]{"provider.classpath", "variable d'environnement CLASSPATH du fournisseur"}, new Object[]{"output.in.RFC.style", "sortie au style RFC"}, new Object[]{"signature.algorithm.name", "nom de l'algorithme de signature"}, new Object[]{"source.alias", "alias source"}, new Object[]{"source.key.password", "mot de passe de la clé source"}, new Object[]{"source.keystore.name", "nom du fichier de clés source"}, new Object[]{"source.keystore.password.protected", "mot de passe du fichier de clés source protégé"}, new Object[]{"source.keystore.provider.name", "nom du fournisseur du fichier de clés source"}, new Object[]{"source.keystore.password", "mot de passe du fichier de clés source"}, new Object[]{"source.keystore.type", "type du fichier de clés source"}, new Object[]{"SSL.server.host.and.port", "Port et hôte du serveur SSL"}, new Object[]{"signed.jar.file", "fichier JAR signé"}, new Object[]{"certificate.validity.start.date.time", "date/heure de début de validité du certificat"}, new Object[]{"keystore.password", "mot de passe du fichier de clés"}, new Object[]{"keystore.type", "type du fichier de clés"}, new Object[]{"trust.certificates.from.cacerts", "certificats sécurisés issus de certificats CA"}, new Object[]{"verbose.output", "sortie en mode verbose"}, new Object[]{"validity.number.of.days", "nombre de jours de validité"}, new Object[]{"Serial.ID.of.cert.to.revoke", "ID de série du certificat à révoquer"}, new Object[]{"keytool.error.", "erreur keytool : "}, new Object[]{"Illegal.option.", "Option non admise :  "}, new Object[]{"Illegal.value.", "Valeur non admise : "}, new Object[]{"Unknown.password.type.", "Type de mot de passe inconnu : "}, new Object[]{"Cannot.find.environment.variable.", "Variable d'environnement introuvable : "}, new Object[]{"Cannot.find.file.", "Fichier introuvable : "}, new Object[]{"Command.option.flag.needs.an.argument.", "L''option de commande {0} requiert un argument."}, new Object[]{"Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.", "Avertissement : les mots de passe de clé et de banque distincts ne sont pas pris en charge pour les fichiers de clés d''accès PKCS12. La valeur {0} spécifiée par l''utilisateur est ignorée."}, new Object[]{".keystore.must.be.NONE.if.storetype.is.{0}", "-keystore doit être défini sur NONE si -storetype est {0}"}, new Object[]{"Too.many.retries.program.terminated", "Trop de tentatives, fin du programme"}, new Object[]{".storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}", "Les commandes -storepasswd et -keypasswd ne sont pas prises en charge si -storetype est défini sur {0}"}, new Object[]{".keypasswd.commands.not.supported.if.storetype.is.PKCS12", "Les commandes -keypasswd ne sont pas prises en charge si -storetype est défini sur PKCS12"}, new Object[]{".keypass.and.new.can.not.be.specified.if.storetype.is.{0}", "Les commandes -keypass et -new ne peuvent pas être spécifiées si -storetype est défini sur {0}"}, new Object[]{"if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified", "si -protected est spécifié, -storepass, -keypass et -new ne doivent pas être indiqués"}, new Object[]{"if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified", "Si -srcprotected est indiqué, les commandes -srcstorepass et -srckeypass ne doivent pas être spécifiées"}, new Object[]{"if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified", "Si le fichier de clés n'est pas protégé par un mot de passe, les commandes -storepass, -keypass et -new ne doivent pas être spécifiées"}, new Object[]{"if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified", "Si le fichier de clés source n'est pas protégé par un mot de passe, les commandes -srcstorepass et -srckeypass ne doivent pas être spécifiées"}, new Object[]{"Illegal.startdate.value", "Valeur de date de début non admise"}, new Object[]{"Validity.must.be.greater.than.zero", "La validité doit être supérieure à zéro"}, new Object[]{"provName.not.a.provider", "{0} n''est pas un fournisseur"}, new Object[]{"Usage.error.no.command.provided", "Erreur de syntaxe : aucune commande fournie"}, new Object[]{"Source.keystore.file.exists.but.is.empty.", "Le fichier de clés source existe mais il est vide : "}, new Object[]{"Please.specify.srckeystore", "Indiquez -srckeystore"}, new Object[]{"Must.not.specify.both.v.and.rfc.with.list.command", "-v et -rfc ne doivent pas être spécifiés avec la commande 'list'"}, new Object[]{"Key.password.must.be.at.least.6.characters", "Un mot de passe de clé doit comporter au moins 6 caractères"}, new Object[]{"New.password.must.be.at.least.6.characters", "Le nouveau mot de passe doit comporter au moins 6 caractères"}, new Object[]{"Keystore.file.exists.but.is.empty.", "Fichier de clés existant mais vide : "}, new Object[]{"Keystore.file.does.not.exist.", "Le fichier de clés n'existe pas : "}, new Object[]{"Must.specify.destination.alias", "L'alias de destination doit être spécifié"}, new Object[]{"Must.specify.alias", "L'alias doit être spécifié"}, new Object[]{"Keystore.password.must.be.at.least.6.characters", "Un mot de passe de fichier de clés doit comporter au moins 6 caractères"}, new Object[]{"Enter.the.password.to.be.stored.", "Saisissez le mot de passe à stocker :  "}, new Object[]{"Enter.keystore.password.", "Entrez le mot de passe du fichier de clés :  "}, new Object[]{"Enter.source.keystore.password.", "Entrez le mot de passe du fichier de clés source :  "}, new Object[]{"Enter.destination.keystore.password.", "Entrez le mot de passe du fichier de clés de destination :  "}, new Object[]{"Keystore.password.is.too.short.must.be.at.least.6.characters", "Le mot de passe du fichier de clés est trop court : il doit comporter au moins 6 caractères"}, new Object[]{"Unknown.Entry.Type", "Type d'entrée inconnu"}, new Object[]{"Too.many.failures.Alias.not.changed", "Trop d'erreurs. Alias non modifié"}, new Object[]{"Entry.for.alias.alias.successfully.imported.", "L''entrée de l''alias {0} a été importée."}, new Object[]{"Entry.for.alias.alias.not.imported.", "L''entrée de l''alias {0} n''a pas été importée."}, new Object[]{"Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.", "Problème lors de l''import de l''entrée de l''alias {0} : {1}.\nL''entrée de l''alias {0} n''a pas été importée."}, new Object[]{"Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled", "Commande d''import exécutée : {0} entrées importées, échec ou annulation de {1} entrées"}, new Object[]{"Warning.Overwriting.existing.alias.alias.in.destination.keystore", "Avertissement : l''alias {0} existant sera remplacé dans le fichier de clés d''accès de destination"}, new Object[]{"Existing.entry.alias.alias.exists.overwrite.no.", "L''alias d''entrée {0} existe déjà. Voulez-vous le remplacer ? [non] :  "}, new Object[]{"Too.many.failures.try.later", "Trop d'erreurs. Réessayez plus tard"}, new Object[]{"Certification.request.stored.in.file.filename.", "Demande de certification stockée dans le fichier <{0}>"}, new Object[]{"Submit.this.to.your.CA", "Soumettre à votre CA"}, new Object[]{"if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified", "si l'alias n'est pas spécifié, destalias et srckeypass ne doivent pas être spécifiés"}, new Object[]{"The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.", "Le fichier de clés pkcs12 de destination contient un mot de passe de fichier de clés et un mot de passe de clé différents. Réessayez en spécifiant -destkeypass."}, new Object[]{"Certificate.stored.in.file.filename.", "Certificat stocké dans le fichier <{0}>"}, new Object[]{"Certificate.reply.was.installed.in.keystore", "Réponse de certificat installée dans le fichier de clés"}, new Object[]{"Certificate.reply.was.not.installed.in.keystore", "Réponse de certificat non installée dans le fichier de clés"}, new Object[]{"Certificate.was.added.to.keystore", "Certificat ajouté au fichier de clés"}, new Object[]{"Certificate.was.not.added.to.keystore", "Certificat non ajouté au fichier de clés"}, new Object[]{".Storing.ksfname.", "[Stockage de {0}]"}, new Object[]{"alias.has.no.public.key.certificate.", "{0} ne possède pas de clé publique (certificat)"}, new Object[]{"Cannot.derive.signature.algorithm", "Impossible de déduire l'algorithme de signature"}, new Object[]{"Alias.alias.does.not.exist", "L''alias <{0}> n''existe pas"}, new Object[]{"Alias.alias.has.no.certificate", "L''alias <{0}> ne possède pas de certificat"}, new Object[]{"Key.pair.not.generated.alias.alias.already.exists", "Paire de clés non générée, l''alias <{0}> existe déjà"}, new Object[]{"Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for", "Génération d''une paire de clés {1} de {0} bits et d''un certificat auto-signé ({2}) d''une validité de {3} jours\n\tpour : {4}"}, new Object[]{"Enter.key.password.for.alias.", "Entrez le mot de passe de la clé pour <{0}>"}, new Object[]{".RETURN.if.same.as.keystore.password.", "\t(appuyez sur Entrée s'il s'agit du mot de passe du fichier de clés) :  "}, new Object[]{"Key.password.is.too.short.must.be.at.least.6.characters", "Le mot de passe de la clé est trop court : il doit comporter au moins 6 caractères"}, new Object[]{"Too.many.failures.key.not.added.to.keystore", "Trop d'erreurs. Clé non ajoutée au fichier de clés"}, new Object[]{"Destination.alias.dest.already.exists", "L''alias de la destination <{0}> existe déjà"}, new Object[]{"Password.is.too.short.must.be.at.least.6.characters", "Le mot de passe est trop court : il doit comporter au moins 6 caractères"}, new Object[]{"Too.many.failures.Key.entry.not.cloned", "Trop d'erreurs. Entrée de clé non clonée"}, new Object[]{"key.password.for.alias.", "mot de passe de clé pour <{0}>"}, new Object[]{"Keystore.entry.for.id.getName.already.exists", "L''entrée de fichier de clés d''accès pour <{0}> existe déjà"}, new Object[]{"Creating.keystore.entry.for.id.getName.", "Création d''une entrée de fichier de clés d''accès pour <{0}>..."}, new Object[]{"No.entries.from.identity.database.added", "Aucune entrée ajoutée à partir de la base de données d'identités"}, new Object[]{"Alias.name.alias", "Nom d''alias : {0}"}, new Object[]{"Creation.date.keyStore.getCreationDate.alias.", "Date de création : {0,date}"}, new Object[]{"alias.keyStore.getCreationDate.alias.", "{0}, {1,date}, "}, new Object[]{"alias.", "{0}, "}, new Object[]{"Entry.type.type.", "Type d''entrée : {0}"}, new Object[]{"Certificate.chain.length.", "Longueur de chaîne du certificat : "}, new Object[]{"Certificate.i.1.", "Certificat[{0,number,integer}]:"}, new Object[]{"Certificate.fingerprint.SHA1.", "Empreinte du certificat (SHA1) : "}, new Object[]{"Keystore.type.", "Type de fichier de clés : "}, new Object[]{"Keystore.provider.", "Fournisseur de fichier de clés : "}, new Object[]{"Your.keystore.contains.keyStore.size.entry", "Votre fichier de clés d''accès contient {0,number,integer} entrée"}, new Object[]{"Your.keystore.contains.keyStore.size.entries", "Votre fichier de clés d''accès contient {0,number,integer} entrées"}, new Object[]{"Failed.to.parse.input", "L'analyse de l'entrée a échoué"}, new Object[]{"Empty.input", "Entrée vide"}, new Object[]{"Not.X.509.certificate", "Pas un certificat X.509"}, new Object[]{"alias.has.no.public.key", "{0} ne possède pas de clé publique"}, new Object[]{"alias.has.no.X.509.certificate", "{0} ne possède pas de certificat X.509"}, new Object[]{"New.certificate.self.signed.", "Nouveau certificat (auto-signé) :"}, new Object[]{"Reply.has.no.certificates", "La réponse n'a pas de certificat"}, new Object[]{"Certificate.not.imported.alias.alias.already.exists", "Certificat non importé, l''alias <{0}> existe déjà"}, new Object[]{"Input.not.an.X.509.certificate", "L'entrée n'est pas un certificat X.509"}, new Object[]{"Certificate.already.exists.in.keystore.under.alias.trustalias.", "Le certificat existe déjà dans le fichier de clés d''accès sous l''alias <{0}>"}, new Object[]{"Do.you.still.want.to.add.it.no.", "Voulez-vous toujours l'ajouter ? [non] :  "}, new Object[]{"Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.", "Le certificat existe déjà dans le fichier de clés d''accès CA système sous l''alias <{0}>"}, new Object[]{"Do.you.still.want.to.add.it.to.your.own.keystore.no.", "Voulez-vous toujours l'ajouter à votre fichier de clés ? [non] :  "}, new Object[]{"Trust.this.certificate.no.", "Faire confiance à ce certificat ? [non] :  "}, new Object[]{"YES", "OUI"}, new Object[]{"New.prompt.", "Nouveau {0} : "}, new Object[]{"Passwords.must.differ", "Les mots de passe doivent différer"}, new Object[]{"Re.enter.new.prompt.", "Indiquez encore le nouveau {0} : "}, new Object[]{"Re.enter.password.", "Répétez le mot de passe : "}, new Object[]{"Re.enter.new.password.", "Ressaisissez le nouveau mot de passe : "}, new Object[]{"They.don.t.match.Try.again", "Ils sont différents. Réessayez."}, new Object[]{"Enter.prompt.alias.name.", "Indiquez le nom d''alias {0} :  "}, new Object[]{"Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.", "Saisissez le nom du nouvel alias\t(ou appuyez sur Entrée pour annuler l'import de cette entrée) :  "}, new Object[]{"Enter.alias.name.", "Indiquez le nom d'alias :  "}, new Object[]{".RETURN.if.same.as.for.otherAlias.", "\t(appuyez sur Entrée si le résultat est identique à <{0}>)"}, new Object[]{"What.is.your.first.and.last.name.", "Quels sont vos nom et prénom ?"}, new Object[]{"What.is.the.name.of.your.organizational.unit.", "Quel est le nom de votre unité organisationnelle ?"}, new Object[]{"What.is.the.name.of.your.organization.", "Quel est le nom de votre entreprise ?"}, new Object[]{"What.is.the.name.of.your.City.or.Locality.", "Quel est le nom de votre ville de résidence ?"}, new Object[]{"What.is.the.name.of.your.State.or.Province.", "Quel est le nom de votre état ou province ?"}, new Object[]{"What.is.the.two.letter.country.code.for.this.unit.", "Quel est le code pays à deux lettres pour cette unité ?"}, new Object[]{"Is.name.correct.", "Est-ce {0} ?"}, new Object[]{"no", "non"}, new Object[]{"yes", "oui"}, new Object[]{PdfOps.y_TOKEN, "o"}, new Object[]{".defaultValue.", "  [{0}]:  "}, new Object[]{"Alias.alias.has.no.key", "L''alias <{0}> n''est associé à aucune clé"}, new Object[]{"Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key", "L''entrée à laquelle l''alias <{0}> fait référence n''est pas une entrée de type clé privée. La commande -keyclone prend uniquement en charge le clonage des clés privées"}, new Object[]{".WARNING.WARNING.WARNING.", "*****************  WARNING WARNING WARNING  *****************"}, new Object[]{"Signer.d.", "Signataire n°%d :"}, new Object[]{"Timestamp.", "Horodatage :"}, new Object[]{"Signature.", "Signature :"}, new Object[]{"CRLs.", "Listes des certificats révoqués (CRL) :"}, new Object[]{"Certificate.owner.", "Propriétaire du certificat : "}, new Object[]{"Not.a.signed.jar.file", "Fichier JAR non signé"}, new Object[]{"No.certificate.from.the.SSL.server", "Aucun certificat du serveur SSL"}, new Object[]{".The.integrity.of.the.information.stored.in.your.keystore.", "* L'intégrité des informations stockées dans votre fichier de clés  *\n* n'a PAS été vérifiée. Pour cela, *\n* vous devez fournir le mot de passe de votre fichier de clés.                  *"}, new Object[]{".The.integrity.of.the.information.stored.in.the.srckeystore.", "* L'intégrité des informations stockées dans le fichier de clés source  *\n* n'a PAS été vérifiée. Pour cela, *\n* vous devez fournir le mot de passe de votre fichier de clés source.                  *"}, new Object[]{"Certificate.reply.does.not.contain.public.key.for.alias.", "La réponse au certificat ne contient pas de clé publique pour <{0}>"}, new Object[]{"Incomplete.certificate.chain.in.reply", "Chaîne de certificat incomplète dans la réponse"}, new Object[]{"Certificate.chain.in.reply.does.not.verify.", "La chaîne de certificat de la réponse ne concorde pas : "}, new Object[]{"Top.level.certificate.in.reply.", "Certificat de niveau supérieur dans la réponse :\n"}, new Object[]{".is.not.trusted.", "... non sécurisé. "}, new Object[]{"Install.reply.anyway.no.", "Installer la réponse quand même ? [non] :  "}, new Object[]{"NO", "NON"}, new Object[]{"Public.keys.in.reply.and.keystore.don.t.match", "Les clés publiques de la réponse et du fichier de clés ne concordent pas"}, new Object[]{"Certificate.reply.and.certificate.in.keystore.are.identical", "La réponse au certificat et le certificat du fichier de clés sont identiques"}, new Object[]{"Failed.to.establish.chain.from.reply", "Impossible de créer une chaîne à partir de la réponse"}, new Object[]{PdfOps.n_TOKEN, PdfOps.n_TOKEN}, new Object[]{"Wrong.answer.try.again", "Réponse incorrecte, recommencez"}, new Object[]{"Secret.key.not.generated.alias.alias.already.exists", "Clé secrète non générée, l''alias <{0}> existe déjà"}, new Object[]{"Please.provide.keysize.for.secret.key.generation", "Indiquez -keysize pour la génération de la clé secrète"}, new Object[]{"warning.not.verified.make.sure.keystore.is.correct", "AVERTISSEMENT : non vérifié. Assurez-vous que -keystore est correct."}, new Object[]{"Extensions.", "Extensions : "}, new Object[]{".Empty.value.", "(Valeur vide)"}, new Object[]{"Extension.Request.", "Demande d'extension :"}, new Object[]{"Unknown.keyUsage.type.", "Type keyUsage inconnu : "}, new Object[]{"Unknown.extendedkeyUsage.type.", "Type extendedkeyUsage inconnu : "}, new Object[]{"Unknown.AccessDescription.type.", "Type AccessDescription inconnu : "}, new Object[]{"Unrecognized.GeneralName.type.", "Type GeneralName non reconnu : "}, new Object[]{"This.extension.cannot.be.marked.as.critical.", "Cette extension ne peut pas être marquée comme critique. "}, new Object[]{"Odd.number.of.hex.digits.found.", "Nombre impair de chiffres hexadécimaux trouvé : "}, new Object[]{"Unknown.extension.type.", "Type d'extension inconnu : "}, new Object[]{"command.{0}.is.ambiguous.", "commande {0} ambiguë :"}, new Object[]{"the.certificate.request", "Demande de certificat"}, new Object[]{"the.issuer", "Emetteur"}, new Object[]{"the.generated.certificate", "Certificat généré"}, new Object[]{"the.generated.crl", "Liste des certificats révoqués générée"}, new Object[]{"the.generated.certificate.request", "Demande de certificat généré"}, new Object[]{"the.certificate", "Certificat"}, new Object[]{"the.crl", "Liste de certificats révoqués"}, new Object[]{"the.tsa.certificate", "Certificat TSA"}, new Object[]{"the.input", "Entrée"}, new Object[]{"reply", "Répondre"}, new Object[]{"one.in.many", "%1$s #%2$d sur %3$d"}, new Object[]{"alias.in.cacerts", "Emetteur <%s> dans les certificats CA"}, new Object[]{"alias.in.keystore", "Emetteur <%s>"}, new Object[]{"with.weak", "%s (faible)"}, new Object[]{"key.bit", "Clé %2$s %1$d bits"}, new Object[]{"key.bit.weak", "Clé %2$s %1$d bits (faible)"}, new Object[]{".PATTERN.printX509Cert.with.weak", "Propriétaire : {0}\nEmetteur : {1}\nNuméro de série : {2}\nValide du : {3} au : {4}\nEmpreintes du certificat :\n\t MD5 : {5}\n\t SHA1 : {6}\n\t SHA256 : {7}\nNom de l''algorithme de signature : {8}\nAlgorithme de clé publique du sujet : {9}\nVersion : {10}"}, new Object[]{"PKCS.10.with.weak", "Demande de certificat PKCS #10 (version 1.0)\nSujet : %1$s\nFormat : %2$s\nClé publique : %3$s\nAlgorithme de signature : %4$s\n"}, new Object[]{"verified.by.s.in.s.weak", "Vérifié par %1$s dans %2$s avec un élément %3$s"}, new Object[]{"whose.sigalg.risk", "%1$s utilise l'algorithme de signature %2$s, qui représente un risque pour la sécurité."}, new Object[]{"whose.key.risk", "%1$s utilise un élément %2$s, qui représente un risque pour la sécurité."}, new Object[]{"jks.storetype.warning", "Le fichier de clés %1$s utilise un format propriétaire. Il est recommandé de migrer vers PKCS12, qui est un format standard de l'industrie en utilisant \"keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\"."}, new Object[]{"migrate.keystore.warning", "Elément \"%1$s\" migré vers %4$s. Le fichier de clés %2$s est sauvegardé en tant que \"%3$s\"."}, new Object[]{"backup.keystore.warning", "Le fichier de clés d'origine \"%1$s\" est sauvegardé en tant que \"%3$s\"..."}, new Object[]{"importing.keystore.status", "Import du fichier de clés %1$s vers %2$s..."}};

    @Override // java.util.ListResourceBundle
    public Object[][] getContents() {
        return contents;
    }
}
