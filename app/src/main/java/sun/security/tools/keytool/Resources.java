package sun.security.tools.keytool;

import java.util.ListResourceBundle;
import org.icepdf.core.util.PdfOps;

/* loaded from: rt.jar:sun/security/tools/keytool/Resources.class */
public class Resources extends ListResourceBundle {
    private static final Object[][] contents = {new Object[]{"NEWLINE", "\n"}, new Object[]{"STAR", "*******************************************"}, new Object[]{"STARNN", "*******************************************\n\n"}, new Object[]{".OPTION.", " [OPTION]..."}, new Object[]{"Options.", "Options:"}, new Object[]{"Use.keytool.help.for.all.available.commands", "Use \"keytool -help\" for all available commands"}, new Object[]{"Key.and.Certificate.Management.Tool", "Key and Certificate Management Tool"}, new Object[]{"Commands.", "Commands:"}, new Object[]{"Use.keytool.command.name.help.for.usage.of.command.name", "Use \"keytool -command_name -help\" for usage of command_name"}, new Object[]{"Generates.a.certificate.request", "Generates a certificate request"}, new Object[]{"Changes.an.entry.s.alias", "Changes an entry's alias"}, new Object[]{"Deletes.an.entry", "Deletes an entry"}, new Object[]{"Exports.certificate", "Exports certificate"}, new Object[]{"Generates.a.key.pair", "Generates a key pair"}, new Object[]{"Generates.a.secret.key", "Generates a secret key"}, new Object[]{"Generates.certificate.from.a.certificate.request", "Generates certificate from a certificate request"}, new Object[]{"Generates.CRL", "Generates CRL"}, new Object[]{"Generated.keyAlgName.secret.key", "Generated {0} secret key"}, new Object[]{"Generated.keysize.bit.keyAlgName.secret.key", "Generated {0}-bit {1} secret key"}, new Object[]{"Imports.entries.from.a.JDK.1.1.x.style.identity.database", "Imports entries from a JDK 1.1.x-style identity database"}, new Object[]{"Imports.a.certificate.or.a.certificate.chain", "Imports a certificate or a certificate chain"}, new Object[]{"Imports.a.password", "Imports a password"}, new Object[]{"Imports.one.or.all.entries.from.another.keystore", "Imports one or all entries from another keystore"}, new Object[]{"Clones.a.key.entry", "Clones a key entry"}, new Object[]{"Changes.the.key.password.of.an.entry", "Changes the key password of an entry"}, new Object[]{"Lists.entries.in.a.keystore", "Lists entries in a keystore"}, new Object[]{"Prints.the.content.of.a.certificate", "Prints the content of a certificate"}, new Object[]{"Prints.the.content.of.a.certificate.request", "Prints the content of a certificate request"}, new Object[]{"Prints.the.content.of.a.CRL.file", "Prints the content of a CRL file"}, new Object[]{"Generates.a.self.signed.certificate", "Generates a self-signed certificate"}, new Object[]{"Changes.the.store.password.of.a.keystore", "Changes the store password of a keystore"}, new Object[]{"alias.name.of.the.entry.to.process", "alias name of the entry to process"}, new Object[]{"destination.alias", "destination alias"}, new Object[]{"destination.key.password", "destination key password"}, new Object[]{"destination.keystore.name", "destination keystore name"}, new Object[]{"destination.keystore.password.protected", "destination keystore password protected"}, new Object[]{"destination.keystore.provider.name", "destination keystore provider name"}, new Object[]{"destination.keystore.password", "destination keystore password"}, new Object[]{"destination.keystore.type", "destination keystore type"}, new Object[]{"distinguished.name", "distinguished name"}, new Object[]{"X.509.extension", "X.509 extension"}, new Object[]{"output.file.name", "output file name"}, new Object[]{"input.file.name", "input file name"}, new Object[]{"key.algorithm.name", "key algorithm name"}, new Object[]{"key.password", "key password"}, new Object[]{"key.bit.size", "key bit size"}, new Object[]{"keystore.name", "keystore name"}, new Object[]{"new.password", "new password"}, new Object[]{"do.not.prompt", "do not prompt"}, new Object[]{"password.through.protected.mechanism", "password through protected mechanism"}, new Object[]{"provider.argument", "provider argument"}, new Object[]{"provider.class.name", "provider class name"}, new Object[]{"provider.name", "provider name"}, new Object[]{"provider.classpath", "provider classpath"}, new Object[]{"output.in.RFC.style", "output in RFC style"}, new Object[]{"signature.algorithm.name", "signature algorithm name"}, new Object[]{"source.alias", "source alias"}, new Object[]{"source.key.password", "source key password"}, new Object[]{"source.keystore.name", "source keystore name"}, new Object[]{"source.keystore.password.protected", "source keystore password protected"}, new Object[]{"source.keystore.provider.name", "source keystore provider name"}, new Object[]{"source.keystore.password", "source keystore password"}, new Object[]{"source.keystore.type", "source keystore type"}, new Object[]{"SSL.server.host.and.port", "SSL server host and port"}, new Object[]{"signed.jar.file", "signed jar file"}, new Object[]{"certificate.validity.start.date.time", "certificate validity start date/time"}, new Object[]{"keystore.password", "keystore password"}, new Object[]{"keystore.type", "keystore type"}, new Object[]{"trust.certificates.from.cacerts", "trust certificates from cacerts"}, new Object[]{"verbose.output", "verbose output"}, new Object[]{"validity.number.of.days", "validity number of days"}, new Object[]{"Serial.ID.of.cert.to.revoke", "Serial ID of cert to revoke"}, new Object[]{"keytool.error.", "keytool error: "}, new Object[]{"Illegal.option.", "Illegal option:  "}, new Object[]{"Illegal.value.", "Illegal value: "}, new Object[]{"Unknown.password.type.", "Unknown password type: "}, new Object[]{"Cannot.find.environment.variable.", "Cannot find environment variable: "}, new Object[]{"Cannot.find.file.", "Cannot find file: "}, new Object[]{"Command.option.flag.needs.an.argument.", "Command option {0} needs an argument."}, new Object[]{"Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.", "Warning:  Different store and key passwords not supported for PKCS12 KeyStores. Ignoring user-specified {0} value."}, new Object[]{".keystore.must.be.NONE.if.storetype.is.{0}", "-keystore must be NONE if -storetype is {0}"}, new Object[]{"Too.many.retries.program.terminated", "Too many retries, program terminated"}, new Object[]{".storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}", "-storepasswd and -keypasswd commands not supported if -storetype is {0}"}, new Object[]{".keypasswd.commands.not.supported.if.storetype.is.PKCS12", "-keypasswd commands not supported if -storetype is PKCS12"}, new Object[]{".keypass.and.new.can.not.be.specified.if.storetype.is.{0}", "-keypass and -new can not be specified if -storetype is {0}"}, new Object[]{"if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified", "if -protected is specified, then -storepass, -keypass, and -new must not be specified"}, new Object[]{"if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified", "if -srcprotected is specified, then -srcstorepass and -srckeypass must not be specified"}, new Object[]{"if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified", "if keystore is not password protected, then -storepass, -keypass, and -new must not be specified"}, new Object[]{"if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified", "if source keystore is not password protected, then -srcstorepass and -srckeypass must not be specified"}, new Object[]{"Illegal.startdate.value", "Illegal startdate value"}, new Object[]{"Validity.must.be.greater.than.zero", "Validity must be greater than zero"}, new Object[]{"provName.not.a.provider", "{0} not a provider"}, new Object[]{"Usage.error.no.command.provided", "Usage error: no command provided"}, new Object[]{"Source.keystore.file.exists.but.is.empty.", "Source keystore file exists, but is empty: "}, new Object[]{"Please.specify.srckeystore", "Please specify -srckeystore"}, new Object[]{"Must.not.specify.both.v.and.rfc.with.list.command", "Must not specify both -v and -rfc with 'list' command"}, new Object[]{"Key.password.must.be.at.least.6.characters", "Key password must be at least 6 characters"}, new Object[]{"New.password.must.be.at.least.6.characters", "New password must be at least 6 characters"}, new Object[]{"Keystore.file.exists.but.is.empty.", "Keystore file exists, but is empty: "}, new Object[]{"Keystore.file.does.not.exist.", "Keystore file does not exist: "}, new Object[]{"Must.specify.destination.alias", "Must specify destination alias"}, new Object[]{"Must.specify.alias", "Must specify alias"}, new Object[]{"Keystore.password.must.be.at.least.6.characters", "Keystore password must be at least 6 characters"}, new Object[]{"Enter.the.password.to.be.stored.", "Enter the password to be stored:  "}, new Object[]{"Enter.keystore.password.", "Enter keystore password:  "}, new Object[]{"Enter.source.keystore.password.", "Enter source keystore password:  "}, new Object[]{"Enter.destination.keystore.password.", "Enter destination keystore password:  "}, new Object[]{"Keystore.password.is.too.short.must.be.at.least.6.characters", "Keystore password is too short - must be at least 6 characters"}, new Object[]{"Unknown.Entry.Type", "Unknown Entry Type"}, new Object[]{"Too.many.failures.Alias.not.changed", "Too many failures. Alias not changed"}, new Object[]{"Entry.for.alias.alias.successfully.imported.", "Entry for alias {0} successfully imported."}, new Object[]{"Entry.for.alias.alias.not.imported.", "Entry for alias {0} not imported."}, new Object[]{"Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.", "Problem importing entry for alias {0}: {1}.\nEntry for alias {0} not imported."}, new Object[]{"Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled", "Import command completed:  {0} entries successfully imported, {1} entries failed or cancelled"}, new Object[]{"Warning.Overwriting.existing.alias.alias.in.destination.keystore", "Warning: Overwriting existing alias {0} in destination keystore"}, new Object[]{"Existing.entry.alias.alias.exists.overwrite.no.", "Existing entry alias {0} exists, overwrite? [no]:  "}, new Object[]{"Too.many.failures.try.later", "Too many failures - try later"}, new Object[]{"Certification.request.stored.in.file.filename.", "Certification request stored in file <{0}>"}, new Object[]{"Submit.this.to.your.CA", "Submit this to your CA"}, new Object[]{"if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified", "if alias not specified, destalias and srckeypass must not be specified"}, new Object[]{"The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.", "The destination pkcs12 keystore has different storepass and keypass. Please retry with -destkeypass specified."}, new Object[]{"Certificate.stored.in.file.filename.", "Certificate stored in file <{0}>"}, new Object[]{"Certificate.reply.was.installed.in.keystore", "Certificate reply was installed in keystore"}, new Object[]{"Certificate.reply.was.not.installed.in.keystore", "Certificate reply was not installed in keystore"}, new Object[]{"Certificate.was.added.to.keystore", "Certificate was added to keystore"}, new Object[]{"Certificate.was.not.added.to.keystore", "Certificate was not added to keystore"}, new Object[]{".Storing.ksfname.", "[Storing {0}]"}, new Object[]{"alias.has.no.public.key.certificate.", "{0} has no public key (certificate)"}, new Object[]{"Cannot.derive.signature.algorithm", "Cannot derive signature algorithm"}, new Object[]{"Alias.alias.does.not.exist", "Alias <{0}> does not exist"}, new Object[]{"Alias.alias.has.no.certificate", "Alias <{0}> has no certificate"}, new Object[]{"Key.pair.not.generated.alias.alias.already.exists", "Key pair not generated, alias <{0}> already exists"}, new Object[]{"Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for", "Generating {0} bit {1} key pair and self-signed certificate ({2}) with a validity of {3} days\n\tfor: {4}"}, new Object[]{"Enter.key.password.for.alias.", "Enter key password for <{0}>"}, new Object[]{".RETURN.if.same.as.keystore.password.", "\t(RETURN if same as keystore password):  "}, new Object[]{"Key.password.is.too.short.must.be.at.least.6.characters", "Key password is too short - must be at least 6 characters"}, new Object[]{"Too.many.failures.key.not.added.to.keystore", "Too many failures - key not added to keystore"}, new Object[]{"Destination.alias.dest.already.exists", "Destination alias <{0}> already exists"}, new Object[]{"Password.is.too.short.must.be.at.least.6.characters", "Password is too short - must be at least 6 characters"}, new Object[]{"Too.many.failures.Key.entry.not.cloned", "Too many failures. Key entry not cloned"}, new Object[]{"key.password.for.alias.", "key password for <{0}>"}, new Object[]{"Keystore.entry.for.id.getName.already.exists", "Keystore entry for <{0}> already exists"}, new Object[]{"Creating.keystore.entry.for.id.getName.", "Creating keystore entry for <{0}> ..."}, new Object[]{"No.entries.from.identity.database.added", "No entries from identity database added"}, new Object[]{"Alias.name.alias", "Alias name: {0}"}, new Object[]{"Creation.date.keyStore.getCreationDate.alias.", "Creation date: {0,date}"}, new Object[]{"alias.keyStore.getCreationDate.alias.", "{0}, {1,date}, "}, new Object[]{"alias.", "{0}, "}, new Object[]{"Entry.type.type.", "Entry type: {0}"}, new Object[]{"Certificate.chain.length.", "Certificate chain length: "}, new Object[]{"Certificate.i.1.", "Certificate[{0,number,integer}]:"}, new Object[]{"Certificate.fingerprint.SHA.256.", "Certificate fingerprint (SHA-256): "}, new Object[]{"Keystore.type.", "Keystore type: "}, new Object[]{"Keystore.provider.", "Keystore provider: "}, new Object[]{"Your.keystore.contains.keyStore.size.entry", "Your keystore contains {0,number,integer} entry"}, new Object[]{"Your.keystore.contains.keyStore.size.entries", "Your keystore contains {0,number,integer} entries"}, new Object[]{"Failed.to.parse.input", "Failed to parse input"}, new Object[]{"Empty.input", "Empty input"}, new Object[]{"Not.X.509.certificate", "Not X.509 certificate"}, new Object[]{"alias.has.no.public.key", "{0} has no public key"}, new Object[]{"alias.has.no.X.509.certificate", "{0} has no X.509 certificate"}, new Object[]{"New.certificate.self.signed.", "New certificate (self-signed):"}, new Object[]{"Reply.has.no.certificates", "Reply has no certificates"}, new Object[]{"Certificate.not.imported.alias.alias.already.exists", "Certificate not imported, alias <{0}> already exists"}, new Object[]{"Input.not.an.X.509.certificate", "Input not an X.509 certificate"}, new Object[]{"Certificate.already.exists.in.keystore.under.alias.trustalias.", "Certificate already exists in keystore under alias <{0}>"}, new Object[]{"Do.you.still.want.to.add.it.no.", "Do you still want to add it? [no]:  "}, new Object[]{"Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.", "Certificate already exists in system-wide CA keystore under alias <{0}>"}, new Object[]{"Do.you.still.want.to.add.it.to.your.own.keystore.no.", "Do you still want to add it to your own keystore? [no]:  "}, new Object[]{"Trust.this.certificate.no.", "Trust this certificate? [no]:  "}, new Object[]{"YES", "YES"}, new Object[]{"New.prompt.", "New {0}: "}, new Object[]{"Passwords.must.differ", "Passwords must differ"}, new Object[]{"Re.enter.new.prompt.", "Re-enter new {0}: "}, new Object[]{"Re.enter.password.", "Re-enter password: "}, new Object[]{"Re.enter.new.password.", "Re-enter new password: "}, new Object[]{"They.don.t.match.Try.again", "They don't match. Try again"}, new Object[]{"Enter.prompt.alias.name.", "Enter {0} alias name:  "}, new Object[]{"Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.", "Enter new alias name\t(RETURN to cancel import for this entry):  "}, new Object[]{"Enter.alias.name.", "Enter alias name:  "}, new Object[]{".RETURN.if.same.as.for.otherAlias.", "\t(RETURN if same as for <{0}>)"}, new Object[]{"What.is.your.first.and.last.name.", "What is your first and last name?"}, new Object[]{"What.is.the.name.of.your.organizational.unit.", "What is the name of your organizational unit?"}, new Object[]{"What.is.the.name.of.your.organization.", "What is the name of your organization?"}, new Object[]{"What.is.the.name.of.your.City.or.Locality.", "What is the name of your City or Locality?"}, new Object[]{"What.is.the.name.of.your.State.or.Province.", "What is the name of your State or Province?"}, new Object[]{"What.is.the.two.letter.country.code.for.this.unit.", "What is the two-letter country code for this unit?"}, new Object[]{"Is.name.correct.", "Is {0} correct?"}, new Object[]{"no", "no"}, new Object[]{"yes", "yes"}, new Object[]{PdfOps.y_TOKEN, PdfOps.y_TOKEN}, new Object[]{".defaultValue.", "  [{0}]:  "}, new Object[]{"Alias.alias.has.no.key", "Alias <{0}> has no key"}, new Object[]{"Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key", "Alias <{0}> references an entry type that is not a private key entry.  The -keyclone command only supports cloning of private key entries"}, new Object[]{".WARNING.WARNING.WARNING.", "*****************  WARNING WARNING WARNING  *****************"}, new Object[]{"Signer.d.", "Signer #%d:"}, new Object[]{"Timestamp.", "Timestamp:"}, new Object[]{"Signature.", "Signature:"}, new Object[]{"CRLs.", "CRLs:"}, new Object[]{"Certificate.owner.", "Certificate owner: "}, new Object[]{"Not.a.signed.jar.file", "Not a signed jar file"}, new Object[]{"No.certificate.from.the.SSL.server", "No certificate from the SSL server"}, new Object[]{".The.integrity.of.the.information.stored.in.your.keystore.", "* The integrity of the information stored in your keystore  *\n* has NOT been verified!  In order to verify its integrity, *\n* you must provide your keystore password.                  *"}, new Object[]{".The.integrity.of.the.information.stored.in.the.srckeystore.", "* The integrity of the information stored in the srckeystore*\n* has NOT been verified!  In order to verify its integrity, *\n* you must provide the srckeystore password.                *"}, new Object[]{"Certificate.reply.does.not.contain.public.key.for.alias.", "Certificate reply does not contain public key for <{0}>"}, new Object[]{"Incomplete.certificate.chain.in.reply", "Incomplete certificate chain in reply"}, new Object[]{"Certificate.chain.in.reply.does.not.verify.", "Certificate chain in reply does not verify: "}, new Object[]{"Top.level.certificate.in.reply.", "Top-level certificate in reply:\n"}, new Object[]{".is.not.trusted.", "... is not trusted. "}, new Object[]{"Install.reply.anyway.no.", "Install reply anyway? [no]:  "}, new Object[]{"NO", "NO"}, new Object[]{"Public.keys.in.reply.and.keystore.don.t.match", "Public keys in reply and keystore don't match"}, new Object[]{"Certificate.reply.and.certificate.in.keystore.are.identical", "Certificate reply and certificate in keystore are identical"}, new Object[]{"Failed.to.establish.chain.from.reply", "Failed to establish chain from reply"}, new Object[]{PdfOps.n_TOKEN, PdfOps.n_TOKEN}, new Object[]{"Wrong.answer.try.again", "Wrong answer, try again"}, new Object[]{"Secret.key.not.generated.alias.alias.already.exists", "Secret Key not generated, alias <{0}> already exists"}, new Object[]{"Please.provide.keysize.for.secret.key.generation", "Please provide -keysize for secret key generation"}, new Object[]{"warning.not.verified.make.sure.keystore.is.correct", "WARNING: not verified. Make sure -keystore is correct."}, new Object[]{"Extensions.", "Extensions: "}, new Object[]{".Empty.value.", "(Empty value)"}, new Object[]{"Extension.Request.", "Extension Request:"}, new Object[]{"Unknown.keyUsage.type.", "Unknown keyUsage type: "}, new Object[]{"Unknown.extendedkeyUsage.type.", "Unknown extendedkeyUsage type: "}, new Object[]{"Unknown.AccessDescription.type.", "Unknown AccessDescription type: "}, new Object[]{"Unrecognized.GeneralName.type.", "Unrecognized GeneralName type: "}, new Object[]{"This.extension.cannot.be.marked.as.critical.", "This extension cannot be marked as critical. "}, new Object[]{"Odd.number.of.hex.digits.found.", "Odd number of hex digits found: "}, new Object[]{"Unknown.extension.type.", "Unknown extension type: "}, new Object[]{"command.{0}.is.ambiguous.", "command {0} is ambiguous:"}, new Object[]{"the.certificate.request", "The certificate request"}, new Object[]{"the.issuer", "The issuer"}, new Object[]{"the.generated.certificate", "The generated certificate"}, new Object[]{"the.generated.crl", "The generated CRL"}, new Object[]{"the.generated.certificate.request", "The generated certificate request"}, new Object[]{"the.certificate", "The certificate"}, new Object[]{"the.crl", "The CRL"}, new Object[]{"the.tsa.certificate", "The TSA certificate"}, new Object[]{"the.input", "The input"}, new Object[]{"reply", "Reply"}, new Object[]{"one.in.many", "%1$s #%2$d of %3$d"}, new Object[]{"alias.in.cacerts", "Issuer <%s> in cacerts"}, new Object[]{"alias.in.keystore", "Issuer <%s>"}, new Object[]{"with.weak", "%s (weak)"}, new Object[]{"with.disabled", "%s (disabled)"}, new Object[]{"key.bit", "%1$d-bit %2$s key"}, new Object[]{"key.bit.weak", "%1$d-bit %2$s key (weak)"}, new Object[]{"key.bit.disabled", "%1$d-bit %2$s key (disabled)"}, new Object[]{"unknown.size.1", "unknown size %s key"}, new Object[]{".PATTERN.printX509Cert.with.weak", "Owner: {0}\nIssuer: {1}\nSerial number: {2}\nValid from: {3} until: {4}\nCertificate fingerprints:\n\t SHA1: {5}\n\t SHA256: {6}\nSignature algorithm name: {7}\nSubject Public Key Algorithm: {8}\nVersion: {9}"}, new Object[]{"PKCS.10.with.weak", "PKCS #10 Certificate Request (Version 1.0)\nSubject: %1$s\nFormat: %2$s\nPublic Key: %3$s\nSignature algorithm: %4$s\n"}, new Object[]{"verified.by.s.in.s.weak", "Verified by %1$s in %2$s with a %3$s"}, new Object[]{"whose.sigalg.disabled", "%1$s uses the %2$s signature algorithm which is considered a security risk and is disabled."}, new Object[]{"whose.sigalg.weak", "%1$s uses the %2$s signature algorithm which is considered a security risk. This algorithm will be disabled in a future update."}, new Object[]{"whose.key.disabled", "%1$s uses a %2$s which is considered a security risk and is disabled."}, new Object[]{"whose.key.weak", "%1$s uses a %2$s which is considered a security risk. This key size will be disabled in a future update."}, new Object[]{"jks.storetype.warning", "The %1$s keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using \"keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\"."}, new Object[]{"migrate.keystore.warning", "Migrated \"%1$s\" to %4$s. The %2$s keystore is backed up as \"%3$s\"."}, new Object[]{"backup.keystore.warning", "The original keystore \"%1$s\" is backed up as \"%3$s\"..."}, new Object[]{"importing.keystore.status", "Importing keystore %1$s to %2$s..."}};

    @Override // java.util.ListResourceBundle
    public Object[][] getContents() {
        return contents;
    }
}
